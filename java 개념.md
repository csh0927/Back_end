### 클래스

자바에서 클래스란 객체를 정의하는 틀 또는 설게도와 같은 의미로 사용된다. 자바에서는 이러한 설계도인 클래스를 가지고 여러 객체를 생성하여 사용하게 되고 클래스는 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성된다.

```
public class Test {
  ...
}
```

### 필드

필드란 클래스의 포함된 변수를 의미한다. 클래스 변수, 인스턴스 변수, 지역 변수로 구분된다. 클래스 변수는 클래스가 메로리에 올라갈 때 생성되고 프로그램이 종료될때 소멸한다. 인스턴스 변수는 인스턴스가 생성될 때 생성되고 인스턴스가 소멸할 때 소멸된다. 지역변수는 메소드 내에서 변수의 선언문이 실행될 때 생성되고 메소드를 벗어날 때 소멸된다.

```
public class Student {
    static int num = 10; // 클래스 변수
    String name; // 인스턴스 변수
    
    public void print() {
        String str; // 지역 변수
        str = num + name;
        System.out.println(str);
    }
```

### 메소드

메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

### 인스턴스
- 인스턴스란 현실의 객체(고유 속성을 가지는 모든 대상)를  소프트웨어 내에서 구현한 실체라고 볼 수 있다. 생성된 인스턴스들은 각자 고유의 특성을 가지고 독립적으로 존재한다.
  - 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
  - 실체화하는 것을 “클래스를 인스턴스화 하다”라고 표현한다.
  - 인스턴스는 어떤 원본으로부터 생성된 복제본을 의미한다.

```
public class PersonTest{
    public void main(String[] args){
        // 객체 생성 = 인스턴스
        Person per = new Person();
        
        // 메소드 사용
        per.eat();
        per.walk();
        per.sleep();
	}
}

```

### 인터페이스
자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있지만 자바는 다중 상속이 되지 않는다. 그래서 인터페이스라는 것을 통해 다중 상속을 지원한다. 인터페이스는 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.

### 생성자
자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자라는 메소드를 제공한다. 자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 한다. 생성자는 반환값이 없지만 반환 타입을 void형으로 선언하지 않고 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다. 
객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다.
여기서 **생성자와 메소드의 차이**는 생성자는 상속이 되지 않으며, 오버라이딩의 대상이 될 수 없다.
메소드와 호출 방식이 다르다. 생성자는 클래스의 이름과 같아야 하며, 반환형이 없다. 또한 void표기가 필요 없다.

### final
자바에서 클래스나 변수를 정의할 때 final 키워드를 사용할 수 있다. 클래스나 변수에 final을 붙이면 한번 초기화를 시킨후 값이 바뀌지 않는다.

### 추상 클래스

- A클래스, B클래스, C클래스가 있다고 했을 때 이 실체 클래스 안에 있는 공통적인 필드와 메소드를 추출해 만들어진 클래스이다. (필드는 변수, 메소드는 클래스 내부에 있는 함수라고 생각하면 된다.)
  - 예를 들어 ‘키보드’라는 클래스가 있다면 ‘키보드’를 만드는 제조사는 여러개이고 각각 기능이나 부품이 다를 수 있다. 하지만 키보드를 누르는 액션은 공통적이기 때문에 이런 메소드를 추상클래스에 둔다고 생각하면된다.
- 추상 클래스는 메소드와 내용이 실체성이 없고 구체적이지 않기 때문에 객체를 생성할 수 없다. 하지만 실체 클래스는 구체성이 있어서 실제 객체를 생성할 수 있다.
- 실체 클래스는 추상 클래스를 상속받아 재정의(오버라이딩)해야한다
- 클래스와 메소드에는 abstract라는 키워드를 이용해서 정의한다.

```
//추상 클래스
public abstract class Animal {
	public String kind;
	
	//추상 메소드
	public abstract void sound();//구체적인 구현부는 없다
}

public class Dog extends Animal{
	
	public Dog(){
		this.kind = "포유류";
	}
	
	@Override
	public void sound() {
		System.out.println("왈왈!");
	}
}

```

- 추상 클래스를 사용하는 이유
  - 공통 필드와 메소드를 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다.
  - 실체 클래스를 구현할 때, 시간을 절약할 수 있고 구현에만 집중할 수 있게된다.
  - 규격에 맞게 소스가 구현되어 있어서 규격에 따라 구현부만 수정하면 손 쉽게 기능 수정이 가능하다.