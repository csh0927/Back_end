# @Transactional

### 트랜잭션의 필요성

데이터 수정 도중에 예외가 발생된다면 수정 전으로 돌아가야하는데, 여러 작업을 진행하다가 문제가 생겼을 때 이전 상태로 롤백하기 위해 사용되는 것이 트랜잭션이다.

* Spring에서 제공하는 트랜잭션
  1. 개발식 트랜잭션
     * 트랜잭션 매니저에서 트랜잭션을 얻어오는 방법
     * 가독성을 떨어뜨리고, 휴먼에러가 유발될 수 있으므로 잘 사용하지 않는다.
       * 휴먼에러란 시스템의 성능, 안전 또는 효율을 저하시키는 잠재력을 가지고 있는 부적절 하거나 우너치 앟는 인간의 결정이나 행동으로 어떤 허용범위를 벗어난 일련의 인간동작
  2. 선언적 트랜잭션 (어노테이션)
     * 스프링의 AOP를 적극적으로 체감가능하다.
     * xml에서 AOP 설정으로 트랜잭션을 선언하는 방법

### @Transactional 이란?

**개별 메소드나 클래스에 붙을 수 있는 트랜잭션 특성**

* xlass레벨의 어노테이션은 선언된 클래스와 그의 서브클래스 내부에 있는 모든 메소드에 적용된다. (조상 클래스로 올라가 적용되지는 않음)

구현은 어떻게 될까?

1. 스프링은 해당 메소드를 감싼 프록시 객체를 생성
2. 메소드 앞뒤에 트랜잭션 로직을 삽입(begin-commit/rollback)
3. public method에만 프록시 객체 생성

* 특성
  * 커스텀 롤백 룰이 적용되지 않았다면, 트랜잭션은 기본적으로 RuntimeException과 Error가 발생했을시 롤백된다.
  * 실제로 에러는 아닌데, 우리에게는 에러인 그런것들은 롤백이 안된다는 것이다.
    (시간차로 뭔가가 꼬여서 다른값이 들어가버린다던가 그런것들)
  * 일반적으로 PlatformTransactionManager에 의해 관리되는, thread종속적인 트랜잭션으로 수행된다.
  * 해당 thread안에서 수행되는 데이터 접근 연상들에 트랜잭션이 노출된다.
  * @transactional이 적용된 메소드 내부에서 새롭게 시작되는 thread에는 트랜잭션이 전파되지 않는다.



### 어노테이션 특성들

* isolation : 격리성
  * 트랜잭션 성질 ACID에서 I부분. 트랜잭션들이 서로 얼마나 격리되어있는지 나타낸다.
  * read_uncomitted부터 serializable까지 격리수준이 다양한데, 다 어느정도 문제가 발생할 수 있다.
* propagation : 전파규칙
  * 전파옵션을 고를 수 있고, required 같은 경우는 부모의 트랜잭션에 참여하고, 없으면 새로운 트랜잭션을 시작한다는 뜻.
  * 그 외에도 supports부터 nested까지 다양하다.
* readOnly : 읽기 전용 모드 - false가 기본.
* noRollbackFor : 해당 예외 발생시 롤백안함
* rollbackFor : 해당 예외 발생시 롤백
* timeout : 타임아웃 걸정 가능(기본은 -1로 없다.)
* value : 트랜잭션 매니저 설정

#### 결론

* 한가지 일을 하는 일련의 코드들은 한 단위로 묶어서 작업을 처리하는 방법
* 중간에 오류가 생겼을 경우에 작업 이전으로 되돌려주는 역할을 한다.

